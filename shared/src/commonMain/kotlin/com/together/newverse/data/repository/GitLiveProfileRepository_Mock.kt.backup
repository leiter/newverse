package com.together.newverse.data.repository

import com.together.newverse.domain.model.BuyerProfile
import com.together.newverse.domain.model.Market
import com.together.newverse.domain.model.SellerProfile
import com.together.newverse.domain.repository.ProfileRepository
import com.together.newverse.domain.repository.AuthRepository
import dev.gitlive.firebase.Firebase
import dev.gitlive.firebase.database.database
import dev.gitlive.firebase.database.DatabaseReference
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.map

/**
 * GitLive implementation of ProfileRepository for cross-platform profile management.
 *
 * This implementation will use GitLive's Firebase SDK to provide:
 * - Cross-platform support (Android, iOS, Web, Desktop)
 * - Real-time profile synchronization
 * - Buyer and Seller profile management
 * - Profile data persistence
 *
 * Data structure in Firebase:
 * - /profiles/buyers/{userId} - Buyer profiles
 * - /profiles/sellers/{sellerId} - Seller profiles
 */
class GitLiveProfileRepository(
    private val authRepository: AuthRepository
) : ProfileRepository {

    // GitLive Firebase Database references
    private val database = Firebase.database
    private val buyersRef = database.reference("profiles/buyers")
    private val sellersRef = database.reference("seller_profiles")

    // Local cache for performance
    private val _buyerProfile = MutableStateFlow<BuyerProfile?>(null)
    private val sellerProfileCache = mutableMapOf<String, SellerProfile>()

    /**
     * Observe buyer profile with real-time updates.
     * Returns a Flow that emits profile changes.
     */
    override fun observeBuyerProfile(): Flow<BuyerProfile?> {
        println("üîê GitLiveProfileRepository.observeBuyerProfile: Setting up profile observer")

        // Return a flow that observes the buyer profile in real-time
        return _buyerProfile.asStateFlow()
    }

    /**
     * Get buyer profile for the current authenticated user.
     * Fetches from GitLive Firebase and merges with auth data.
     */
    override suspend fun getBuyerProfile(): Result<BuyerProfile> {
        return try {
            println("üîê GitLiveProfileRepository.getBuyerProfile: START")

            val userId = authRepository.getCurrentUserId()
            if (userId == null) {
                println("‚ùå GitLiveProfileRepository.getBuyerProfile: No authenticated user")
                return Result.failure(Exception("User not authenticated"))
            }

            // TODO: Implement with GitLive
            // val snapshot = buyersRef.child(userId).get()
            // val profileDto = snapshot.value<BuyerProfileDto>()

            // For now, check cache or return mock data
            val cachedProfile = _buyerProfile.value
            if (cachedProfile != null) {
                println("‚úÖ GitLiveProfileRepository.getBuyerProfile: Returning cached profile")
                return Result.success(cachedProfile)
            }

            // Create default profile for testing
            val defaultProfile = createDefaultBuyerProfile(userId)
            _buyerProfile.value = defaultProfile

            println("‚úÖ GitLiveProfileRepository.getBuyerProfile: Created default profile for $userId")
            Result.success(defaultProfile)

        } catch (e: Exception) {
            println("‚ùå GitLiveProfileRepository.getBuyerProfile: Error - ${e.message}")
            Result.failure(e)
        }
    }

    /**
     * Save buyer profile to GitLive Firebase.
     * Updates both local cache and remote database.
     */
    override suspend fun saveBuyerProfile(profile: BuyerProfile): Result<BuyerProfile> {
        return try {
            println("üîê GitLiveProfileRepository.saveBuyerProfile: START - ${profile.displayName}")

            val userId = authRepository.getCurrentUserId()
            if (userId == null) {
                println("‚ùå GitLiveProfileRepository.saveBuyerProfile: No authenticated user")
                return Result.failure(Exception("User not authenticated"))
            }

            // Ensure profile ID matches authenticated user
            val profileWithCorrectId = profile.copy(id = userId)

            // TODO: Implement with GitLive
            // val dto = BuyerProfileDto.fromDomain(profileWithCorrectId)
            // buyersRef.child(userId).setValue(dto)

            // Update local cache
            _buyerProfile.value = profileWithCorrectId

            println("‚úÖ GitLiveProfileRepository.saveBuyerProfile: Success - saved to cache")
            Result.success(profileWithCorrectId)

        } catch (e: Exception) {
            println("‚ùå GitLiveProfileRepository.saveBuyerProfile: Error - ${e.message}")
            Result.failure(e)
        }
    }

    /**
     * Get seller profile by ID.
     * If sellerId is empty, returns the first available seller (for testing).
     */
    override suspend fun getSellerProfile(sellerId: String): Result<SellerProfile> {
        return try {
            println("üîê GitLiveProfileRepository.getSellerProfile: START - sellerId=$sellerId")

            // Check cache first
            if (sellerId.isNotEmpty() && sellerProfileCache.containsKey(sellerId)) {
                println("‚úÖ GitLiveProfileRepository.getSellerProfile: Returning cached profile")
                return Result.success(sellerProfileCache[sellerId]!!)
            }

            // TODO: Implement with GitLive
            // val targetSellerId = if (sellerId.isEmpty()) {
            //     // Get first seller for testing
            //     val allSellers = sellersRef.get()
            //     allSellers.children.firstOrNull()?.key ?: ""
            // } else {
            //     sellerId
            // }
            //
            // val snapshot = sellersRef.child(targetSellerId).get()
            // val profileDto = snapshot.value<SellerProfileDto>()
            // val profile = profileDto?.toDomain()

            // For now, return mock seller profile
            val mockProfile = createMockSellerProfile(sellerId.ifEmpty { "seller_001" })
            sellerProfileCache[mockProfile.id] = mockProfile

            println("‚úÖ GitLiveProfileRepository.getSellerProfile: Created mock profile")
            Result.success(mockProfile)

        } catch (e: Exception) {
            println("‚ùå GitLiveProfileRepository.getSellerProfile: Error - ${e.message}")
            Result.failure(e)
        }
    }

    /**
     * Save seller profile to GitLive Firebase.
     */
    override suspend fun saveSellerProfile(profile: SellerProfile): Result<Unit> {
        return try {
            println("üîê GitLiveProfileRepository.saveSellerProfile: START - ${profile.displayName}")

            // TODO: Implement with GitLive
            // val dto = SellerProfileDto.fromDomain(profile)
            // sellersRef.child(profile.id).setValue(dto)

            // Update cache
            sellerProfileCache[profile.id] = profile

            println("‚úÖ GitLiveProfileRepository.saveSellerProfile: Success - saved to cache")
            Result.success(Unit)

        } catch (e: Exception) {
            println("‚ùå GitLiveProfileRepository.saveSellerProfile: Error - ${e.message}")
            Result.failure(e)
        }
    }

    /**
     * Clear user data from local cache and optionally from Firebase.
     * Used during logout or account deletion.
     */
    override suspend fun clearUserData(sellerId: String, buyerProfile: BuyerProfile): Result<Boolean> {
        return try {
            println("üîê GitLiveProfileRepository.clearUserData: START")

            // Clear local state
            _buyerProfile.value = null
            sellerProfileCache.remove(sellerId)

            // TODO: Optionally clear from Firebase if needed
            // This might not be necessary for logout, only for account deletion

            println("‚úÖ GitLiveProfileRepository.clearUserData: Success - cleared local data")
            Result.success(true)

        } catch (e: Exception) {
            println("‚ùå GitLiveProfileRepository.clearUserData: Error - ${e.message}")
            Result.failure(e)
        }
    }

    // Helper functions

    /**
     * Create a default buyer profile for new users.
     */
    private fun createDefaultBuyerProfile(userId: String): BuyerProfile {
        return BuyerProfile(
            id = userId,
            displayName = "New User",
            emailAddress = "",
            photoUrl = "",
            placedOrderIds = emptyMap()
        )
    }

    /**
     * Create a mock seller profile for testing.
     */
    private fun createMockSellerProfile(sellerId: String): SellerProfile {
        return SellerProfile(
            id = sellerId,
            displayName = when (sellerId) {
                "seller_001" -> "Test Store"
                "seller_002" -> "Demo Shop"
                else -> "GitLive Seller"
            },
            firstName = "Test",
            lastName = "Seller",
            street = "Main Street",
            houseNumber = "123",
            city = "Test City",
            zipCode = "12345",
            telephoneNumber = "+49123456789",
            lat = "52.520008",
            lng = "13.404954",
            sellerId = sellerId,
            markets = emptyList(),
            urls = emptyList(),
            knownClientIds = emptyList()
        )
    }
}

/**
 * Data Transfer Object for Buyer Profile.
 * This would typically be in a separate file but included here for completeness.
 */
private data class BuyerProfileDto(
    val id: String = "",
    val displayName: String = "",
    val emailAddress: String = "",
    val telephoneNumber: String = "",
    val photoUrl: String = "",
    val anonymous: Boolean = true,
    val defaultMarket: String = "",
    val defaultPickUpTime: String = "",
    val placedOrderIds: Map<String, String> = emptyMap(), // Date -> orderId
    val favouriteArticles: List<String> = emptyList()
) {
    fun toDomain(): BuyerProfile {
        return BuyerProfile(
            id = id,
            displayName = displayName,
            emailAddress = emailAddress,
            telephoneNumber = telephoneNumber,
            photoUrl = photoUrl,
            anonymous = anonymous,
            defaultMarket = defaultMarket,
            defaultPickUpTime = defaultPickUpTime,
            placedOrderIds = placedOrderIds,
            favouriteArticles = favouriteArticles
        )
    }

    companion object {
        fun fromDomain(profile: BuyerProfile): BuyerProfileDto {
            return BuyerProfileDto(
                id = profile.id,
                displayName = profile.displayName,
                emailAddress = profile.emailAddress,
                telephoneNumber = profile.telephoneNumber,
                photoUrl = profile.photoUrl,
                anonymous = profile.anonymous,
                defaultMarket = profile.defaultMarket,
                defaultPickUpTime = profile.defaultPickUpTime,
                placedOrderIds = profile.placedOrderIds,
                favouriteArticles = profile.favouriteArticles
            )
        }
    }
}

/**
 * Data Transfer Object for Seller Profile.
 */
private data class SellerProfileDto(
    val id: String = "",
    val displayName: String = "",
    val firstName: String = "",
    val lastName: String = "",
    val street: String = "",
    val houseNumber: String = "",
    val city: String = "",
    val zipCode: String = "",
    val telephoneNumber: String = "",
    val lat: String = "",
    val lng: String = "",
    val sellerId: String = "",
    val markets: List<Market> = emptyList(),
    val urls: List<String> = emptyList(),
    val knownClientIds: List<String> = emptyList()
) {
    fun toDomain(): SellerProfile {
        return SellerProfile(
            id = id,
            displayName = displayName,
            firstName = firstName,
            lastName = lastName,
            street = street,
            houseNumber = houseNumber,
            city = city,
            zipCode = zipCode,
            telephoneNumber = telephoneNumber,
            lat = lat,
            lng = lng,
            sellerId = sellerId,
            markets = markets,
            urls = urls,
            knownClientIds = knownClientIds
        )
    }

    companion object {
        fun fromDomain(profile: SellerProfile): SellerProfileDto {
            return SellerProfileDto(
                id = profile.id,
                displayName = profile.displayName,
                firstName = profile.firstName,
                lastName = profile.lastName,
                street = profile.street,
                houseNumber = profile.houseNumber,
                city = profile.city,
                zipCode = profile.zipCode,
                telephoneNumber = profile.telephoneNumber,
                lat = profile.lat,
                lng = profile.lng,
                sellerId = profile.sellerId,
                markets = profile.markets,
                urls = profile.urls,
                knownClientIds = profile.knownClientIds
            )
        }
    }
}